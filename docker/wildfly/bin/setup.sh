#!/bin/bash

# This setup script performs first-time configuration on Wildfly, echoing
# the installation instructions for a local install.

# Make sure we're in Docker, not at command line
if ! grep --quiet docker /proc/1/cgroup; then
		echo This script should be run from within the wildfly Docker container.
		echo No need for you to run it manually!
		exit
fi

# Function to block execution until Wildfly is fully up and running.
# This is necessary since configuration may not apply properly unless 
# the server is fully up and running. Adapted from 
# https://stackoverflow.com/questions/48702307/how-to-check-if-a-wildfly-server-has-started-successfully-using-command-script
function wait_for_jboss() {
  while true
  do
    # Use JBOSS' command line API to check its status; when that call 
    # returns "running", it's ready.
    if ${JBOSS_CLI} --connect command=':read-attribute(name=server-state)' | grep running
    then
      echo "Wildfly is up!"      
      break
    fi
    echo "Waiting for Wildfly to come up"
    sleep 1
  done
}

# Check if this configuration script had already been run.
if [[ -e ${JBOSS_HOME}/.setupcomplete ]] ; then
  echo "Wildfly seems to be configured; exiting setup and restarting."
  exit
fi

echo "Wildfly may not be configured; running configuration script."
nohup ${JBOSS_HOME}/bin/standalone.sh -c standalone-full.xml &

wait_for_jboss

# Once the server is fully up, we can run configuration for different components. A lot of
# these steps are mirrored from the local installation instructions.

echo "Setting up mail server..."
${JBOSS_CLI} --connect << EOF
/socket-binding-group=standard-sockets/remote-destination-outbound-socket-binding=mail-smtp:write-attribute(name=port,value=25)
/socket-binding-group=standard-sockets/remote-destination-outbound-socket-binding=mail-smtp:write-attribute(name=host,value="mail")
/subsystem=mail/mail-session="java:/Mail":add(jndi-name="java:/Mail")
/subsystem=mail/mail-session="java:/Mail"/server=smtp:add(outbound-socket-binding-ref=mail-smtp)
EOF

echo "Creating message queue..."
${JBOSS_CLI} --connect --command='jms-queue add --queue-address=DataSync --entries=["java:/jms/queue/DataSync"]'

# Set node identifier to unique value
${JBOSS_CLI} --connect << EOF
/subsystem=transactions:write-attribute(name=node-identifier,value=QuietWarning)
EOF

echo "Deploying PostgreSQL driver..."
${JBOSS_CLI} --connect --command="deploy ${JBOSS_HOME}/postgresql.jar"

echo "Configuring Wildfly datasources/databases..."
# Replace DBNAME with the name of the database's Docker container.
DBNAME=psm_db_1; ${JBOSS_CLI} --connect <<EOF
xa-data-source add \
  --name=TaskServiceDS \
  --jndi-name=java:/jdbc/TaskServiceDS \
  --driver-name=postgresql.jar \
  --xa-datasource-class=org.postgresql.xa.PGXADataSource \
  --valid-connection-checker-class-name=org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker \
  --exception-sorter-class-name=org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter \
  --enabled=true \
  --use-ccm=true \
  --background-validation=true \
  --user-name=psm \
  --password=${PWORD} \
  --xa-datasource-properties=ServerName=${DBNAME},PortNumber=5432,DatabaseName=psm
xa-data-source add \
  --name=MitaDS \
  --jndi-name=java:/jdbc/MitaDS \
  --driver-name=postgresql.jar \
  --xa-datasource-class=org.postgresql.xa.PGXADataSource \
  --valid-connection-checker-class-name=org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLValidConnectionChecker \
  --exception-sorter-class-name=org.jboss.jca.adapters.jdbc.extensions.postgres.PostgreSQLExceptionSorter \
  --enabled=true \
  --use-ccm=true \
  --background-validation=true \
  --user-name=psm \
  --password=${PWORD} \
  --xa-datasource-properties=ServerName=${DBNAME},PortNumber=5432,DatabaseName=psm
EOF

echo "Building Liquibase database."
cd /mnt/psm-app
./gradlew db:update -DdatabasePath=jdbc:postgresql://${DBNAME}:5432/psm -DdatabaseUser=${DBUSER} -DdatabasePassword=${PWORD};

# We create a simple file once all steps are complete, indicating that configuration is finished. The script
# checks the existence of this file to determine whether setup needs to be run. If the file doesn't exist,
# then setup will run.
touch ${JBOSS_HOME}/.setupcomplete | echo "This file is generated by the PSM Docker build process. Please do not remove it.\nThe presence of this file indicates that Wildfly configuration has completed successfully." >> ${JBOSS_HOME}/.setupcomplete

echo "Shutting down local Wildfly server after setup."
$JBOSS_CLI -c ":shutdown"